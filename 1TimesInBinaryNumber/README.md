## 题目

```
 请实现一个函数 输入一个整数,输出该数的二进制表示中1的个数
 例如 把 9表示成二进制是1001 有2位是1 因此如果输入9 则该函数输出2
```

## 思路

### 常规算法

这道题是为了考察二进制和位运算

> 先判断二进制中最右面的一位是否为1(通过将这个整数于1进行与操作 如果结果为1则末位为1 否则不唯一) 
> 把输入的整数右移一位 这样之前从右面数第二位的 就排在了最后一位 在判断是不是1
> 一直这样移动 一直到 输入的数变成0

但是这种思路存在一个致命的问题 如果输入的是一个负数那么容易因为 左边的第一位是符号位而导致死循环 

为了避免死循环：
我们不在对输入的数字进行右移操作而是对1进行左移操作
> 通过与1的与操作判断末位是否为1
> 将1 左移变为10 与输入的数进行与操作判断右面第二位是否为1

这个算法的复杂度是 O(n) 取决于输入数字的长度

### 改进算法

> 将输入的数-1 然后将得到的结果 与之前输入的数字进行与操作 这样可以去掉输入的数字中右面的第一个1

举例:
1010 
1、1010-1 = 1001
2、将 1010 & 1001 = 1000; 这样就去掉了一个1 
3、不断循环1 ，2 知道输入的这个数变成0



## 代码实现

### 常规算法

```c++
int NumberOf1(int n)
{
    int count = 0;
    unsigned int flag = 1;
    while (flag)
    {
        if (n & flag)
            count++;
        
        flag = flag << 1;
    }
    
    return count;
}

```

### 改进算法

```c++
int NumberOf1_2(int n)
{
    int count = 0;
    
    while (n)
    {
        ++count;
        n = (n - 1) & n;
    }
    
    return count;
}
```

